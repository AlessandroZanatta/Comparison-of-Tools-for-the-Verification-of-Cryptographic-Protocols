(*
 * Anonymous Diffie-Hellman
 *)

set preciseActions = true.

(********************************************************************************)
(* Exponentiation definitions                                                   *)
(********************************************************************************)

type G. (* Group *)
type Z. (* Integer *)

(*
 * Constant used to define the used group.
 *)
const g: G [data].

(*
 * Diffie-Hellman exponentiation function.
 *
 * Only a (very) limited number of algebraic properties can be associated to 
 * the operation.
 *)
fun exp(G, Z): G.

(*
 * We model the commutativity of the exponents using an equation.
 *)
equation forall x: Z, y: Z;
  exp(exp(g,x), y) = exp(exp(g,y), x).


(********************************************************************************)
(* Encryption definitions                                                       *)
(********************************************************************************)

(*
 * Defines types used to exchange a message.
 *)
type Plaintext.
type Ciphertext.
type Key.

const CtoS: Plaintext.
const StoC: Plaintext.


(*
 * Convenience functions. [typeConverter] functions are used to "bypass" the
 * type system, i.e., to cast a term into a different type.
 *)
fun group2key(G): Key [typeConverter].

(*
 * Deterministic symmetric encryption definition.
 *)
fun enc(bitstring, Key): Ciphertext.

reduc forall m: bitstring, k: Key;
  dec(enc(m, k), k) = m.


(********************************************************************************)
(* Secret messages, events and and queries definition                           *)
(********************************************************************************)

(* Events are used to define a trace over which security properties are defined. *)
event ClientAcceptedKey(Key).
event ServerAcceptedKey(Key).
event ClientSentMessage(Plaintext, Key).
event ServerReceivedMessage(Plaintext, Key).
event ServerSentMessage(Plaintext, Key).
event ClientReceivedMessage(Plaintext, Key).
event PostRevealedClientEphemeralKey(Z).
event PostRevealedServerEphemeralKeyTable(Z).

(* Key agreement *)
query k1, k2: Key;
  event(ClientAcceptedKey(k1)) && event(ServerAcceptedKey(k2)) ==> k1 = k2.

(* Secrecy Client -> Server *)
query m: Plaintext, k: Key;
  event(ClientSentMessage(m, k)) && attacker(m) ==> false.

(* Secrecy Server -> Client *)
query m: Plaintext, k: Key;
  event(ServerSentMessage(m, k)) && attacker(m) ==> false.

(* Authentication Client -> Server *)
query m: Plaintext, k1, k2: Key;
  event(ServerReceivedMessage(m, k1)) ==> event(ClientSentMessage(m, k2)).

(* Authentication Server -> Client *)
query m: Plaintext, k1, k2: Key;
  event(ClientReceivedMessage(m, k1)) ==> event(ServerSentMessage(m, k2)).

(********************************************************************************)
(* Reachability query definition                                                *)
(********************************************************************************)

query m: Plaintext, k: Key;
  event(ClientSentMessage(m, k)).

query m: Plaintext, k: Key;
  event(ServerReceivedMessage(m, k)).

query m: Plaintext, k: Key;
  event(ServerSentMessage(m, k)).

query m: Plaintext, k: Key;
  event(ClientReceivedMessage(m, k)).



(********************************************************************************)
(* Channels definitions                                                         *)
(********************************************************************************)
channel io.

(********************************************************************************)
(* Tables definitions                                                           *)
(********************************************************************************)

(* Stores the key after it has been agreed on by two parties. *)
table ServerKeyTable(Key).
table ClientKeyTable(Key).

(* 
 * Stores information about values from group G which are - in some 
 * manner (e.g. X.509 certificates) - certificated from the server.
 *
 * Information stored into tables is NOT available to the attacker.
 * This implies that we also should output the value on the public channel io.
 *)
table AuthenticatedValueTable(G).

(*
 * These tables are used to store the ephemeral keys generated by client
 * and server, respectively.
 *)
table ClientEphemeralKeyTable(Z).
table ServerEphemeralKeyTable(Z).

(********************************************************************************)
(* Process macros                                                               *)
(********************************************************************************)

(*
 * Process macros can be used to simplify the definitions of protocols. Here,
 * we define one process macro for each party.
 *)
let Client() =

  (* Generate a fresh ephemeral key for the client *)
  new i: Z;
  insert ClientEphemeralKeyTable(i);

  (* `let` assigns a name to a given term *)
  let g_i = exp(g, i) in

  (* Send g_a to the public channel *)
  out(io, g_i);

  (*
   * in() waits for an incoming message of the expected type.
   * It blocks the process until a message is received.
   *)
  in(io, g_r: G);

  (* Check that the value g_r is actually authenticated *)
  get AuthenticatedValueTable(g_r) in
  let k = group2key(exp(g_r, i)) in
  event ClientAcceptedKey(k);
  insert ClientKeyTable(k);
  0.

let Server() =
  in(io, g_i: G);
  new r: Z;
  insert ServerEphemeralKeyTable(r);
  let g_r = exp(g, r) in
  insert AuthenticatedValueTable(g_r);
  out(io, g_r);
  let k = group2key(exp(g_i, r)) in
  event ServerAcceptedKey(k);
  insert ServerKeyTable(k);
  0.

let ClientSendsMessage() =
  (* Generate fresh message m*)
  new m: Plaintext;

  (* Get client key from table *)
  get ClientKeyTable(k) in

  (*
   * We mark the event of sending out a message m encrypted with key k.
   * This must appear *before* out().
   *)
  event ClientSentMessage(m, k);
  
  (* Send an encrypted message with the new key *)
  out(io, enc((CtoS, m), k));
  0.

let ServerReceivesMessage() = 
  (* Get server key from table *)
  get ServerKeyTable(k) in
  
  (* Receive a ciphertext *)
  in(io, c: Ciphertext);

  (* Check for decryption correctness (i.e. the server has the correct key) *)
  let (=CtoS, m: Plaintext) = dec(c, k) in
  
  (*
   * We mark the event of having received and successfully decrypted a
   * message m with key k. This must appear *after* in().
   *)
  event ServerReceivedMessage(m, k);
  0.

let ServerSendsMessage() =
  (* Generate fresh message m*)
  new m: Plaintext;

  (* Get server key from table *)
  get ServerKeyTable(k) in

  (*
   * We mark the event of sending out a message m encrypted with key k.
   * This must appear *before* out().
   *)
  event ServerSentMessage(m, k);
  
  (* Send an encrypted message with the new key *)
  out(io, enc((StoC, m), k));
  0.

let ClientReceivesMessage() = 
  (* Get client key from table *)
  get ClientKeyTable(k) in
  
  (* Receive a ciphertext *)
  in(io, c: Ciphertext);

  (* Check for decryption correctness (i.e. the client has the correct key) *)
  let (=StoC, m: Plaintext) = dec(c, k) in
  
  (*
   * We mark the event of having received and successfully decrypted a
   * message m with key k. This must appear *after* in().
   *)
  event ClientReceivedMessage(m, k);
  0.

(********************************************************************************)
(* Additional adversary capabilities                                            *)
(********************************************************************************)

let PostRevealClientEphemeralKey =
  (*
   * Here we use phases to indicate that process can be executed only AFTER
   * every process in precedent phases (i.e. in this case, phase 0, which is 
   * the default one).
   *)
  phase 1;

  (* Get the client's ephemeral key and output it *)
  get ClientEphemeralKeyTable(c) in
  out(io, c);
  event PostRevealedClientEphemeralKey(c);
  0.

let PostRevealServerEphemeralKey =
  phase 1;

  (* Get the server's ephemeral key and output it *)
  get ServerEphemeralKeyTable(c) in
  out(io, c);
  event PostRevealedServerEphemeralKeyTable(c);
  0.

(********************************************************************************)
(* Main process                                                                 *)
(********************************************************************************)

process
  !Client() 
  | !Server() 
  | !ClientSendsMessage()
  | !ServerReceivesMessage()
  | !ServerSendsMessage()
  | !ClientReceivesMessage()
  | !PostRevealClientEphemeralKey()
  | !PostRevealServerEphemeralKey()

