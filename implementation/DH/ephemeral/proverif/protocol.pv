(*
 * Anonymous Diffie-Hellman
 *)

(********************************************************************************)
(* Groups definitions                                                           *)
(********************************************************************************)

type G. (* Group *)
type Z. (* Integer *)

(*
 * Constant used to define the group used.
 *)
const g: G [data].

(*
 * Diffie-Hellman exponentiation function.
 *
 * Only a (very) limited number of algebraic properties can be associated to 
 * the operation.
 *)
fun exp(G, Z): G.

(*
 * We model the commutativity of the exponents using an equation.
 *)
equation forall x: Z, y: Z;
  exp(exp(g,x), y) = exp(exp(g,y), x).


(********************************************************************************)
(* Encryption definitions                                                       *)
(********************************************************************************)

(*
 * Defines types used to exchange a message.
 *)
type Plaintext.
type Ciphertext.
type Key.

(*
 * Convenience functions. [typeConverter] functions are used to "bypass" the
 * type system, i.e., to cast a term into a different type.
 *)
fun group2key(G): Key [typeConverter].

(*
 * The following declarations model perfect deterministic symmetric encryption.
 *)
fun enc(Plaintext, Key): Ciphertext.

reduc forall m: Plaintext, k: Key;
  dec(enc(m,k), k) = m.


(********************************************************************************)
(* Query definition                                                             *)
(********************************************************************************)

(* 
 * Secret message. [private] names are not known to the attacker (unless 
 * the protocol leaks it somehow).
 *)
free m: Plaintext [private].

(* Secrecy *)
query attacker(m).

(* Events are used to define a trace over which security properties are defined. *)
event InitiatorSendsMessage(Key).
event ResponderReveicesMessage(Key).


(********************************************************************************)
(* Reachability query definition                                                *)
(********************************************************************************)

query k: Key;
  event(ResponderReveicesMessage(k)).

(*
 * We may also want to test that, for each message received by Q(), there is a
 * *distinct* event generated by P().
 *
 * Injective correspondences tend to be more
 * computationally demanding than simple correspondences.
 *)
query k: Key;
  inj-event(ResponderReveicesMessage(k)) ==> inj-event(InitiatorSendsMessage(k)).


(********************************************************************************)
(* Channels definitions                                                         *)
(********************************************************************************)
channel io.


(********************************************************************************)
(* Process macros                                                               *)
(********************************************************************************)

(*
 * Process macros can be used to simplify the definitions of protocols. Here,
 * we define one process macro for each party.
 *)
let Initiator() =

  (* Generate a fresh ephemeral key for the initiator *)
  new i: Z;

  (* `let` assigns a name to a given term *)
  let g_i = exp(g, i) in

  (* Send g_a to the public channel *)
  out(io, g_i);

  (*
   * in() waits for an incoming message of the expected type.
   * It blocks the process until a message is received.
   *)
  in(io, g_r: G);

  let k = group2key(exp(g_r, i)) in

  (*
   * We mark the event of sending out a message encrypted with key k.
   * This must appear *before* out().
   *)
  event InitiatorSendsMessage(k);

  (* Send an encrypted message with the new key *)
  out(io, enc(m, k));
  0.

let Responder() =
  in(io, g_i: G);
  new r: Z;
  let g_r = exp(g, r) in
  out(io, g_r);
  let k = group2key(exp(g_i, r)) in
  in(io, c: Ciphertext);
  if dec(c, k) = m then
    (*
     * We mark the event of having received and successfully decrypted a
     * message with key k. This must appear *after* in().
     *)
    event ResponderReveicesMessage(k);
  0.

process
  Initiator() | Responder()

